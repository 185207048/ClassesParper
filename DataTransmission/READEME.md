# GRPC使用
```
参考博客
 https://blog.csdn.net/an_gentle_killer/article/details/123282801
 http://doc.oschina.net/grpc
 https://grpc.io/docs/what-is-grpc/introduction/
 https://protobuf.dev/overview/
 https://github.com/grpc/grpc-java/blob/master/README.md
```
## RPC介绍
RPC（Remote Procedure Call）是一种编程模型，它允许程序在网络中的一台计算机（客户机）上调用另一台计算机（服务器）上的过程或方法，就好像调用本地的过程或方法一样。RPC 抽象掉了底层的网络通信细节，使得开发者可以像编写本地程序一样编写分布式程序。

RPC的主要目标是让构建分布式计算（应用程序）变得简单。在RPC系统中，客户端进程可以调用服务器进程中的过程，就像在本地计算机上调用过程一样。当客户端调用远程过程时，客户端的执行被挂起，参数（如果有的话）通过网络发送到服务器，服务器执行请求的过程，将结果发送回客户端，然后客户端继续执行。

这种模型有很多优点，例如，它可以让开发者使用他们熟悉的语言和工具来编写分布式程序，可以使代码更简洁，更易于理解和维护。但是，它也有一些缺点，例如，它隐藏了网络通信的细节，这可能导致一些难以预见的问题，例如网络延迟，连接中断等。
## GRPC介绍
gRPC（Google Remote Procedure Call）是一种高性能、开源和通用的 RPC（远程过程调用）框架，Google 公司发起并开源。gRPC 的目标是使各种环境中的服务能够相互通信。gRPC 提供了一个简单的方法，让客户端应用可以直接调用另一台服务器上的方法，就好像是本地对象的方法一样。

<span style="color:red;">在服务器端，服务器实现这个接口并运行一个gRPC服务器来处理客户端调用。在客户端，客户端有一个存根（在某些语言中简称为客户端），它提供与服务器相同的方法。</span>

以下是 gRPC 出现的原因和主要特性：

1.多语言支持：gRPC 支持多种语言，如 Go、Python、Java、C++ 等，使开发者可以在他们熟悉的编程环境中开发应用程序。

2.性能：gRPC 基于 HTTP/2，支持双向流、流控制、头部压缩、多路复用等特性。相比于基于 HTTP/1.1 的 RESTful API，gRPC 有更高的性能和更低的延迟。

3.编码效率：gRPC 默认使用 Protocol Buffers 作为接口定义语言，该语言能够自动生成客户端和服务器代码。相比 JSON 和 XML，Protocol Buffers 的编码和解码效率更高，数据更小。

4.连续性和可扩展性：在分布式系统中，gRPC 能够支持客户端和服务器之间的稳定、可靠和低延迟的双向通信。同时，gRPC 也支持连接数的扩展。

5.强大的生态系统：由于是 Google 的开源项目，gRPC 享有强大的生态系统和社区支持，这对于项目的持续改进和问题的解决具有很大的帮助。

因此，gRPC 的出现主要是为了满足现代分布式系统中的高效、跨语言、稳定和可扩展的通信需求。

- 双向流
  双向流是一种网络通信模型，其中客户端和服务器可以在任何时刻都可以发送数据，即数据可以在两个方向上流动。这种模型在很多网络协议中都有应用，包括 HTTP/2、WebSocket、gRPC 等。

  `双向流的好处`：

    - `性能`：在一些场景中，双向流可以提高性能，因为它们可以减少网络延迟。如果客户端和服务器都可以随时发送数据，那么当他们有数据要发送时，就不需要等待对方的响应。
    - `灵活性`：双向流为应用提供了更大的灵活性。例如，在一些复杂的交互模式中，双向流可能会使得通信更加简单和直接。
    - `实时性`：在需要实时交互的应用中，比如聊天应用或在线游戏，双向流可以提供更好的用户体验，因为它可以实时地传输数据。

- 流控制
- 头部压缩
- 多路复用
- Protocol Buffers
- 批处理
- 拥塞控制
- 低延迟：由于上述各种优化和特性，gRPC 可以提供低延迟的 RPC 调用，这对于需要快速响应的应用来说，非常重要。

## Service有四种服务类型
第一种(`一元 RPC`)：是客户端向服务器发送单个请求并获取单个响应，就像正常的函数调用一样。
```
rpc SayHello(HelloRequest) returns (HelloResponse);
```

<span style="color:green;">使用环境：适用于简单的请求和响应场景，例如获取单个数据项、执行简单的计算等。</span>

第二种(`服务器流式 RPC`)：

客户端向服务器发送请求并获取流以读回一系列消息。

客户端从返回的流中读取，直到没有更多消息为止。

gRPC 保证单个 RPC 调用内的消息排序。

```
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
```

<span style="color:green;">使用环境：适用于服务器端有多个消息需要返回给客户端的场景，例如实时数据推送、日志流式处理等。</span>

第三种(`客户端流式 RPC`)：

客户端流式 RPC 允许客户端以流式方式发送多个请求消息给服务器，服务器则发送单个响应消息。

```
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
```

<span style="color:green;">适用于客户端有多个消息需要发送给服务器进行处理的场景，例如上传大文件、流式数据的聚合等。</span>

第四种(`双向流式 RPC`)：

双向流式 RPC 允许客户端和服务器之间建立一个双向的流式通道，双方可以同时发送多个消息。客户端和服务器可以按需发送和处理消息。

```
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
```

<span style="color:green;">适用于需要在客户端和服务器之间进行实时双向通信的场景，例如聊天应用、实时协作系统等。</span>

## 元数据(Metadata)

## Rpc生命周期
`一元RPC`

1、一旦客户端调用存根方法，服务器就会收到通知，该 RPC 已被调用，并包含此调用的客户端元数据、方法名称和指定的截止时间（如果适用）。

2、然后，服务器可以立即发回自己的初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。

3、一旦服务器收到客户端的请求消息，它就会执行创建和填充响应所需的任何工作。然后，响应连同状态详细信息（状态代码和可选状态消息）以及可选的尾随元数据一起返回给客户端（如果成功）。

4、如果响应状态为 OK，则客户端收到响应，从而完成客户端的调用。

![一元RPC.png](一元RPC.png)

`服务器流式 RPC`

服务器流式 RPC 与一元 RPC 类似，<span style="color:red;">不同之处在于服务器返回消息流</span>以响应客户端的请求。

![服务器流式RPC.png](服务器流式RPC.png)

`客户端流式 RPC`

客户端流式 RPC 与一元 RPC 类似，不同之处在于客户端向服务器发送消息流而不是单个消息。

![客户端流式RPC.png](客户端流式RPC.png)

`双向流式 RPC`

客户端和服务器端流处理是特定于应用程序的。<span style="color:red;">由于两个流是独立的，因此客户端和服务器可以按任意顺序读写消息。</span>例如，服务器可以等到接收到客户端的所有消息后再写入消息，或者服务器和客户端可以玩“乒乓球”——服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，等等。

![双向流式RPC.png](双向流式RPC.png)

## Deadlines/Timeouts

1、gRPC允许客户端指定等待RPC完成的时间：

在进行RPC调用时，客户端可以设置一个超时时间，即客户端愿意等待RPC完成的时间长度。这个超时时间可以根据实际需求来设定，以确保RPC操作不会无限期地等待响应。

2、服务器可以查询RPC是否超时或剩余多少时间：

服务器端可以查询正在进行的RPC是否已经超过了客户端设置的超时时间，或者还剩下多少时间可以用来完成RPC操作。这样服务器端可以根据超时情况来决定如何处理正在进行的RPC。

3、指定截止日期或超时是特定于语言的：

不同的编程语言在gRPC框架中对于超时处理的方式可能有所不同。

有些语言的API基于超时时间（持续时间）工作，即客户端设置一个持续时间，表示等待的时间长度。

而有些语言的API基于截止日期（固定时间点）工作，即客户端设置一个具体的时间点，表示等待到该时间点后就认为RPC超时。

另外，某些语言的API可能没有默认的截止日期或超时时间，需要显式地设置。

## 元数据

<span style="color:red;">元数据是有关特定 RPC 调用的信息（例如身份验证详细信息），采用键值对列表的形式，其中键是字符串，值通常是字符串，但也可以是二进制数据。 键不区分大小写，由 ASCII 字母、数字和特殊字符 -、_、. 组成。</span>并且不能以 grpc- 开头（这是为 gRPC 本身保留的）。二进制值键以 -bin 结尾，而 ASCII 值键则不然。 gRPC 不使用用户定义的元数据，这允许客户端提供与服务器调用相关的信息，反之亦然。 对元数据的访问取决于语言。

## 通道

<span style="color:red;">gRPC 通道提供与指定主机和端口上的 gRPC 服务器的连接。</span>它在创建客户端存根时使用。客户端可以指定通道参数来修改 gRPC 的默认行为，例如打开或关闭消息压缩。通道有状态，包括连接和空闲。 gRPC 如何处理关闭通道取决于语言。某些语言还允许查询通道状态。

# 导航

## 认证
GRPC提供了以下几种身份认证方法：

`SSL/TLS`、`ALTS`、`Token-based authentication with Google`

## Java基础
```http://doc.oschina.net/grpc?t=60134```

### 创建服务器

### 面试题

1、什么是gRPC？它与其他RPC框架有什么不同之处？

gRPC是一种高性能、开源的远程过程调用框架，由Google开发并基于Protocol Buffers（protobuf）实现。</br>
与其他RPC框架相比，gRPC具有以下不同之处：</br>
支持多种编程语言，包括C++, Java, Python, Go等，以及通过生成的客户端库支持其他语言。</br>
使用HTTP/2协议进行高效的双向流式通信，支持并发、复用连接和头部压缩等特性。</br>
支持四种不同的服务类型：一元RPC、服务器流式RPC、客户端流式RPC和双向流式RPC。</br>
基于IDL（接口定义语言）和Protocol Buffers进行序列化和通信，提供强类型和可扩展的数据交换。</br>

2、gRPC支持的编程语言有哪些？有什么优势？

gRPC支持多种编程语言，包括C++, Java, Python, Go, Ruby, C#, Node.js等。此外，通过生成的客户端库，也可以支持其他语言。</br>
优势：</br>
多语言支持使得不同团队和服务可以使用自己熟悉的编程语言进行开发，提高了开发效率和灵活性。</br>
共享相同的接口定义和通信协议，可以实现跨语言的服务调用，使得跨团队或跨服务的集成更加简便。</br>

3、gRPC使用什么协议进行数据传输？为什么选择这个协议？

gRPC使用HTTP/2作为底层的数据传输协议。
HTTP/2相比于传统的HTTP/1.1具有以下优势：</br>
支持双向流式通信，可以同时在单个TCP连接上进行多个请求和响应。</br>
提供头部压缩和二进制格式的帧传输，减少了数据传输的大小和延迟。</br>
支持服务器推送（Server Push）和流量控制等特性，提高了网络性能和效率。</br>

4、gRPC的四种服务类型是什么？请详细描述每种类型的用途和适用场景。

一元RPC（Unary RPC）：适用于简单的请求和响应场景，客户端发送一个请求消息，服务器处理请求并返回单个响应消息。</br>
服务器流式RPC（Server Streaming RPC）：适用于服务器端有多个消息需要返回给客户端的场景，服务器以流式方式发送多个响应消息，客户端按需处理这些消息。</br>
客户端流式RPC（Client Streaming RPC）：适用于客户端有多个消息需要发送给服务器进行处理的场景，客户端以流式方式发送多个请求消息给服务器，服务器发送单个响应消息。</br>
双向流式RPC（Bidirectional Streaming RPC）：适用于需要在客户端和服务器之间进行实时双向通信的场景，双方可以同时发送和接收多个消息。</br>

5、如何处理gRPC中的错误和异常？有哪些常见的错误类型？

gRPC使用状态码和元数据来处理错误和异常。常见的错误类型包括：
DEADLINE_EXCEEDED：超时错误，表示操作在指定的截止时间之前没有完成。</br>
UNAVAILABLE：服务不可用错误，表示无法连接到服务端。</br>
INVALID_ARGUMENT：无效参数错误，表示请求中包含无效或不合法的参数。</br>
UNAUTHENTICATED：未经身份验证错误，表示未经身份验证的访问尝试。</br>
NOT_FOUND：未找到错误，表示请求的资源或服务不存在。</br>

6、如何处理gRPC中的身份验证和安全性？

gRPC提供了多种身份验证和安全性机制，包括基于SSL/TLS的传输层安全（TLS），认证和授权服务，以及自定义的身份验证插件等。</br>
可以使用TLS进行通信加密和认证，保护数据的机密性和完整性。</br>
可以使用认证和授权服务（如OAuth、JWT等）对客户端进行身份验证和授权。</br>
可以编写自定义的身份验证插件，以满足特定的安全需求。</br>

7、gRPC的序列化机制是什么？有哪些支持的序列化格式？

gRPC使用Protocol Buffers（protobuf）作为默认的序列化机制。</br>
Protocol Buffers是一种高效、可扩展的二进制序列化格式，通过定义结构化消息格式和生成对应的代码，实现了跨语言和跨平台的数据交换。</br>
gRPC还支持其他的序列化格式，如JSON，可以根据需要进行选择。</br>

8、如何处理gRPC中的流式数据传输？请解释客户端流式、服务器流式和双向流式的工作原理。

客户端流式RPC：客户端以流式方式发送多个请求消息给服务器，服务器发送单个响应消息。客户端可以根据需求发送多个请求，服务器在接收到请求后进行处理，并在最后返回单个响应消息。</br>
服务器流式RPC：客户端发送一个请求消息，服务器以流式方式发送多个响应消息给客户端。客户端发送请求后等待，服务器逐个发送响应消息，客户端可以按需处理这些消息。</br>
双向流式RPC：客户端和服务器之间建立一个双向的流式通道，双方可以同时发送和接收多个消息。客户端和服务器可以按需发送和处理消息，实现实时的双向通信。</br>

9、gRPC如何处理版本兼容性和迁移？有哪些相关的最佳实践？

gRPC使用Protocol Buffers定义接口和消息格式，这使得版本兼容性和迁移更加容易。</br>
通过在接口定义中添加新的字段和消息，可以实现向后兼容性。</br>
通过在接口定义中使用标记为"reserved"的字段，可以实现向前兼容性。</br>
使用gRPC的版本控制策略，可以管理和协调服务端和客户端的版本更新。</br>
在进行版本迁移时，可以使用渐进式更新的方式，逐步替换旧版本的服务和客户端。</br>

10、gRPC的性能如何？有哪些因素会影响其性能？如何进行性能优化？

gRPC具有很高的性能，相比其他RPC框架，其主要性能优势在于使用了HTTP/2协议和二进制传输。</br>
影响gRPC性能的因素包括网络延迟、带宽、消息大小、服务器资源等。</br>
为了优化gRPC性能，可以考虑以下方面：</br>
使用合适的消息大小，避免过大的消息传输。</br>
合理设置并发连接数和线程池大小，以充分利用服务器资源。</br>
使用流式传输，减少连接建立和关闭的开销。</br>
启用HTTP/2的头部压缩和流量控制特性，减少网络传输的负载。</br>
使用TLS加密保证数据的机密性和完整性。</br>

## 区别
以下是一些常见的RPC框架以及与gRPC的区别：

Apache Thrift:

Thrift是一个跨语言的RPC框架，由Apache开发。它支持多种编程语言，并使用自己的IDL（接口定义语言）来定义数据结构和服务接口。
区别：
Thrift支持更多的编程语言和平台，包括C++, Java, Python, Ruby等，相比之下，gRPC的语言支持相对较少。
Thrift使用自己的二进制协议进行序列化，而gRPC使用Protocol Buffers进行序列化。
Thrift提供更多的数据传输协议选项，包括TCP、HTTP和ZeroMQ等，而gRPC主要使用HTTP/2。
Apache Dubbo:

Dubbo是一个基于Java的高性能RPC框架，由阿里巴巴开发。它提供了分布式服务治理和负载均衡等功能，适用于构建大规模分布式系统。
区别：
Dubbo主要针对Java开发，并提供了更多与分布式系统相关的功能，如服务注册中心、负载均衡、故障转移等。
gRPC是一个通用的RPC框架，支持多种编程语言和平台，并且更加注重跨语言的兼容性和性能。
RESTful API:

REST（Representational State Transfer）是一种基于HTTP协议的通信架构，通过使用统一的URL和HTTP方法来暴露服务接口。
区别：
RESTful API是一种轻量级的通信方式，使用HTTP协议，可以通过URL进行简单的服务调用，但缺乏像RPC框架那样的强类型和基于IDL的通信。
gRPC提供了更丰富的功能和更高效的通信，通过使用Protocol Buffers进行序列化和反序列化，以及使用HTTP/2进行高效的双向流式通信。